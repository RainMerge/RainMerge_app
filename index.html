<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Climate Analysis Tool – Realistic Earth</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: radial-gradient(ellipse at bottom, #0b132b 0%, #000000 100%);
        min-height: 100vh;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        color: white;
    }

    #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: rgba(255,255,255,0.8);
        font-size: 1.2em;
        letter-spacing: 1px;
        font-weight: 500;
        animation: pulse 1.5s infinite;
        z-index: 5;
    }

    @keyframes pulse {
        0%, 100% { opacity: 0.3; }
        50% { opacity: 1; }
    }

    .btn-container {
        position: absolute;
        bottom: 70px;
        text-align: center;
        opacity: 0;
        transform: translateY(40px);
        animation: fadeInBtn 1s ease-out 3s forwards;
        z-index: 10;
    }

    @keyframes fadeInBtn {
        to { opacity: 1; transform: translateY(0); }
    }

    .btn {
        background: linear-gradient(135deg, #007cf0 0%, #00dfd8 100%);
        color: white;
        border: none;
        padding: 16px 60px;
        font-size: 1.2em;
        border-radius: 40px;
        cursor: pointer;
        box-shadow: 0 10px 40px rgba(0, 223, 216, 0.5);
        font-weight: 600;
        transition: all 0.4s ease;
        text-decoration: none;
        letter-spacing: 0.4px;
    }
    .btn:hover { transform: translateY(-5px); }

    .credit {
        position: absolute;
        bottom: 15px;
        font-size: 12px;
        color: rgba(255,255,255,0.6);
        user-select: none;
    }
    .credit a { color: rgba(255,255,255,0.8); text-decoration: underline; }
</style>
</head>
<body>
<div id="loading">Loading Earth...</div>
<canvas id="earthCanvas"></canvas>

<div class="btn-container">
    <a href="https://YOUR_CLOUDFLARE_URL_HERE/guacamole" class="btn" target="_blank">Launch Tool</a>
</div>

<div class="credit">
    Textures © NASA Earth Observatory • Powered by Three.js
</div>

<script type="module">
/* Import via absolute CDN URLs */
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/controls/OrbitControls.js";

/* Scene, camera, renderer setup */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 0.4, 2.6);

const renderer = new THREE.WebGLRenderer({
    canvas: document.getElementById("earthCanvas"),
    antialias: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

/* ✅ CORS-safe high-quality textures (served via JSDelivr) */
const loader = new THREE.TextureLoader();
const texColor = loader.load("https://cdn.jsdelivr.net/gh/rajtilakjee/earth-globe-textures@main/earthmap4k.jpg", removeLoading);
const texBump  = loader.load("https://cdn.jsdelivr.net/gh/rajtilakjee/earth-globe-textures@main/earthbump.jpg");
const texSpec  = loader.load("https://cdn.jsdelivr.net/gh/rajtilakjee/earth-globe-textures@main/earthspec.jpg");
const texCloud = loader.load("https://cdn.jsdelivr.net/gh/rajtilakjee/earth-globe-textures@main/earthcloudmaptrans.jpg");
const texNight = loader.load("https://cdn.jsdelivr.net/gh/rajtilakjee/earth-globe-textures@main/earthlights.jpg");

/* Earth (day side) */
const gEarth = new THREE.SphereGeometry(1, 96, 96);
const mEarth = new THREE.MeshPhongMaterial({
    map: texColor,
    bumpMap: texBump,
    bumpScale: 0.045,
    specularMap: texSpec,
    specular: new THREE.Color("grey"),
    shininess: 10,
});
const earth = new THREE.Mesh(gEarth, mEarth);
scene.add(earth);

/* Night lights layer */
const gNight = new THREE.SphereGeometry(1.001, 96, 96);
const mNight = new THREE.MeshBasicMaterial({
    map: texNight,
    blending: THREE.AdditiveBlending,
    opacity: 0.6,
    transparent: true,
});
const night = new THREE.Mesh(gNight, mNight);
scene.add(night);

/* Cloud layer */
const gClouds = new THREE.SphereGeometry(1.01, 96, 96);
const mClouds = new THREE.MeshLambertMaterial({
    map: texCloud,
    transparent: true,
    opacity: 0.35,
    depthWrite: false
});
const clouds = new THREE.Mesh(gClouds, mClouds);
scene.add(clouds);

/* Atmospheric glow */
const gAtm = new THREE.SphereGeometry(1.06, 96, 96);
const mAtm = new THREE.MeshBasicMaterial({ color: 0x3aa8ff, transparent: true, opacity: 0.18 });
const atmosphere = new THREE.Mesh(gAtm, mAtm);
scene.add(atmosphere);

/* Lighting setup: simulate day–night terminator */
scene.add(new THREE.AmbientLight(0x222222));
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(5, 2, 5);
scene.add(sun);

/* Starfield */
const stars = (() => {
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(6000 * 3);
    for (let i = 0; i < 6000; i++) {
        pos[i * 3] = (Math.random() - 0.5) * 2000;
        pos[i * 3 + 1] = (Math.random() - 0.5) * 2000;
        pos[i * 3 + 2] = -Math.random() * 2000;
    }
    geom.setAttribute("position", new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({ size: 1, color: 0xffffff });
    return new THREE.Points(geom, mat);
})();
scene.add(stars);

/* Orbit controls */
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enableZoom = false;
controls.enablePan = false;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.35;

/* Remove loading overlay when Earth loads */
function removeLoading() {
    const el = document.getElementById("loading");
    if (el) el.remove();
}

/* Resize listener */
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

/* Animate */
const clock = new THREE.Clock();
function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    clouds.rotation.y += dt * 0.015;
    night.rotation.y = earth.rotation.y;
    controls.update();
    renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
