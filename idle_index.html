<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Idle Mode - Click to wake</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  html,body{height:100%}
  body{
    font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
    background:radial-gradient(ellipse at bottom,#0b132b 0%,#000 100%);
    color:#fff;overflow:hidden;
    cursor: pointer;
  }
  #credit{
    position:absolute;right:10px;bottom:10px;z-index:5;
    background:rgba(0,0,0,.35);padding:6px 10px;border-radius:6px;font-size:12px
  }
  #wakeHint{
    position:absolute;left:50%;top:10%;transform:translateX(-50%);
    font-size:.95rem;color:rgba(255,255,255,.5);letter-spacing:.4px;
    animation: fadeInOut 3s infinite;
  }
  @keyframes fadeInOut {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.8; }
  }
</style>
</head>
<body>
<div id="wakeHint">Click anywhere to wake...</div>
<div id="credit">Textures: three.js examples, NASA derived.</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/controls/OrbitControls.js";

/* ---------- Scene ---------- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 0, 4);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ---------- Raycast to read UV under cursor ---------- */
const raycaster = new THREE.Raycaster();
const pointer   = new THREE.Vector2();
const globeUV   = new THREE.Vector2(0.0, 0.0);

/* ---------- Textures (CORS-safe absolute URLs) ---------- */
const loader = new THREE.TextureLoader();
loader.setCrossOrigin('anonymous');

const TEX_SPRITE = "https://threejs.org/examples/textures/sprites/circle.png";
const TEX_COLOR  = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_atmos_4096.jpg";
const TEX_ELEV   = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_normal_2048.jpg";
const TEX_ALPHA  = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_specular_2048.jpg";
const TEX_OTHER  = "https://threejs.org/examples/textures/uv_grid_opengl.jpg";

const starSprite = loader.load(TEX_SPRITE);
const colorMap   = loader.load(TEX_COLOR);
const elevMap    = loader.load(TEX_ELEV);
const alphaMap   = loader.load(TEX_ALPHA);
const otherMap   = loader.load(TEX_OTHER);

/* ---------- Globe group ---------- */
const globeGroup = new THREE.Group();
scene.add(globeGroup);

/* Pickable wireframe shell with UVs */
const pickGeo = new THREE.IcosahedronGeometry(1.0, 16);
const pickMat = new THREE.MeshBasicMaterial({ color:0x0099ff, wireframe:true, transparent:true, opacity:0.10 });
const globePickMesh = new THREE.Mesh(pickGeo, pickMat);
globeGroup.add(globePickMesh);

/* Point cloud shell with custom shaders */
const detail = 120;
const pointsGeo = new THREE.IcosahedronGeometry(1.0, detail);

const vertexShader = `
  uniform float size;
  uniform sampler2D elevTexture;
  uniform vec2 mouseUV;

  varying vec2 vUv;
  varying float vVisible;
  varying float vDist;

  void main(){
    vUv = uv;

    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);

    vec3 vNormal = normalize(normalMatrix * normal);
    vVisible = step(0.0, dot(-normalize(mvPosition.xyz), normalize(vNormal)));

    float elv = texture2D(elevTexture, vUv).r;
    mvPosition.z += 0.35 * elv;

    float dist = distance(mouseUV, vUv);
    float thresh = 0.04;
    float zDisp = 0.0;
    if (dist < thresh) {
      zDisp = (thresh - dist) * 10.0;
    }
    vDist = dist;
    mvPosition.z += zDisp;

    gl_PointSize = size;
    gl_Position = projectionMatrix * mvPosition;
  }
`;

const fragmentShader = `
  uniform sampler2D colorTexture;
  uniform sampler2D alphaTexture;
  uniform sampler2D otherTexture;

  varying vec2 vUv;
  varying float vVisible;
  varying float vDist;

  void main(){
    if (floor(vVisible + 0.1) == 0.0) discard;

    float alpha = 1.0 - texture2D(alphaTexture, vUv).r;

    vec3 color = texture2D(colorTexture, vUv).rgb;
    vec3 other = texture2D(otherTexture, vUv).rgb;

    float thresh = 0.04;
    if (vDist < thresh) {
      float t = (thresh - vDist) * 50.0;
      color = mix(color, other, clamp(t, 0.0, 1.0));
    }
    gl_FragColor = vec4(color, alpha);
  }
`;

const uniforms = {
  size:         { value: 4.0 },
  colorTexture: { value: colorMap },
  otherTexture: { value: otherMap },
  elevTexture:  { value: elevMap },
  alphaTexture: { value: alphaMap },
  mouseUV:      { value: new THREE.Vector2(0.0, 0.0) }
};

const pointsMat = new THREE.ShaderMaterial({
  uniforms, vertexShader, fragmentShader,
  transparent: true, depthWrite: false
});

const points = new THREE.Points(pointsGeo, pointsMat);
globeGroup.add(points);

/* ---------- Lights ---------- */
const hemi = new THREE.HemisphereLight(0xffffff, 0x080820, 2.5);
scene.add(hemi);

/* ---------- Simple starfield ---------- */
function getStarfield({ numStars=4500, sprite=starSprite } = {}){
  const g = new THREE.BufferGeometry();
  const positions = new Float32Array(numStars * 3);
  const r = 100;
  for (let i=0;i<numStars;i++){
    const theta = Math.random() * Math.PI * 2.0;
    const phi   = Math.acos(2.0 * Math.random() - 1.0);
    const rad   = r + Math.random() * 50.0;
    positions[i*3+0] = rad * Math.sin(phi) * Math.cos(theta);
    positions[i*3+1] = rad * Math.sin(phi) * Math.sin(theta);
    positions[i*3+2] = rad * Math.cos(phi);
  }
  g.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  return new THREE.Points(g, new THREE.PointsMaterial({ map:sprite, size:2.0, transparent:true, depthWrite:false, color:0xffffff }));
}
scene.add(getStarfield({}));

/* ---------- Raycast pointer to UV ---------- */
function handleRaycast(){
  raycaster.setFromCamera(pointer, camera);
  const hits = raycaster.intersectObjects([globePickMesh], false);
  if (hits.length > 0 && hits[0].uv) globeUV.copy(hits[0].uv);
  uniforms.mouseUV.value.copy(globeUV);
}

/* ---------- Animate ---------- */
function animate(){
  globeGroup.rotation.y += 0.002;
  handleRaycast();
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/* ---------- Events ---------- */
addEventListener('mousemove', (e)=>{
  pointer.set((e.clientX/innerWidth)*2-1, -(e.clientY/innerHeight)*2+1);
});
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ---------- Return to main app on any click ---------- */
addEventListener('click', () => {
  const returnUrl = sessionStorage.getItem('returnUrl') || 'index.html';
  console.log('Waking up - returning to:', returnUrl);
  window.location.href = returnUrl;
});
</script>
</body>
</html>
